This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-04T07:35:48.095Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

# Directory Structure
```
.github/
  workflows/
    unit-test.yml
migration/
  src/
    lib.rs
    m20250213_100210_create_table_users.rs
    m20250213_105425_create_table_posts.rs
    main.rs
  Cargo.toml
  README.md
proto/
  post.proto
  user.proto
src/
  domain/
    entity/
      mod.rs
      post.rs
      prelude.rs
      users.rs
    repository/
      mod.rs
      post.rs
      user.rs
    mod.rs
  handler/
    mod.rs
    post_handler.rs
    user_handler.rs
  infra/
    client.rs
    mod.rs
  repository/
    mod.rs
    post_repository.rs
    user_repository.rs
  usecase/
    mod.rs
    post_usecase.rs
    user_usecase.rs
  main.rs
.gitignore
.octocov.yml
build.rs
Cargo.toml
docker-compose.yml
Makefile
README.md
```

# Files

## File: .github/workflows/unit-test.yml
```yaml
name: Rust CI with Postgres and seaORM Migrations

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: myuser
          POSTGRES_PASSWORD: mypassword
          POSTGRES_DB: talk_app
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    env:
      DATABASE_URL: postgres://myuser:mypassword@localhost:5432/talk_app
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install protoc
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          override: true
          components: llvm-tools-preview

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      - name: Cache cargo git index
        uses: actions/cache@v3
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-git-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-git-

      - name: Cache target directory
        uses: actions/cache@v3
        with:
          path: target
          key: ${{ runner.os }}-cargo-target-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-target-

      - name: Run seaORM migrations
        run: |
          cd migration
          cargo run -- up

      - name: Build and test with coverage
        run: cargo llvm-cov test --workspace --all-features --lcov --output-path lcov.info
        env:
          CARGO_INCREMENTAL: '0'
          RUSTFLAGS: '-C instrument-coverage'

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: lcov.info
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true
```

## File: migration/src/lib.rs
```rust
pub use sea_orm_migration::prelude::*;

mod m20250213_100210_create_table_users;
mod m20250213_105425_create_table_posts;

pub struct Migrator;

#[async_trait::async_trait]
impl MigratorTrait for Migrator {
    fn migrations() -> Vec<Box<dyn MigrationTrait>> {
        vec![
            Box::new(m20250213_100210_create_table_users::Migration),
            Box::new(m20250213_105425_create_table_posts::Migration),
        ]
    }
}
```

## File: migration/src/m20250213_100210_create_table_users.rs
```rust
use sea_orm::sea_query::Expr;
use sea_orm_migration::prelude::*;

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(Users::Table)
                    .if_not_exists()
                    .col(
                        ColumnDef::new(Users::Id)
                            .integer()
                            .not_null()
                            .auto_increment()
                            .primary_key(),
                    )
                    .col(ColumnDef::new(Users::Name).string().not_null())
                    .col(ColumnDef::new(Users::Email).string().not_null())
                    .col(ColumnDef::new(Users::Description).string().null())
                    .col(ColumnDef::new(Users::Age).integer().null())
                    .col(ColumnDef::new(Users::Gender).string().null())
                    .col(ColumnDef::new(Users::Address).string().null())
                    .col(
                        ColumnDef::new(Users::CreatedAt)
                            .timestamp()
                            .not_null()
                            .default(Expr::cust("CURRENT_TIMESTAMP")),
                    )
                    .col(
                        ColumnDef::new(Users::UpdatedAt)
                            .timestamp()
                            .not_null()
                            .default(Expr::cust("CURRENT_TIMESTAMP")),
                    )
                    .col(ColumnDef::new(Users::DeletedAt).timestamp().null())
                    .to_owned(),
            )
            .await
            .expect("create table users");

        manager
            .create_index(
                Index::create()
                    .name("idx_name")
                    .table(Users::Table)
                    .col(Users::Name)
                    .to_owned(),
            )
            .await
            .expect("create index idx_name");

        manager
            .create_index(
                Index::create()
                    .name("idx_age")
                    .table(Users::Table)
                    .col(Users::Age)
                    .to_owned(),
            )
            .await
            .expect("create index idx_age");

        manager
            .create_index(
                Index::create()
                    .name("idx_sex")
                    .table(Users::Table)
                    .col(Users::Gender)
                    .to_owned(),
            )
            .await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(Users::Table).to_owned())
            .await
    }
}

#[derive(DeriveIden)]
pub enum Users {
    Table,
    Id,
    Name,
    Email,
    Description,
    Gender,
    Age,
    Address,
    CreatedAt,
    UpdatedAt,
    DeletedAt,
}
```

## File: migration/src/m20250213_105425_create_table_posts.rs
```rust
use crate::m20250213_100210_create_table_users::Users;
use sea_orm_migration::{prelude::*, schema::*};

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(Post::Table)
                    .if_not_exists()
                    .col(pk_auto(Post::Id))
                    .col(string(Post::Body).not_null())
                    .col(integer(Post::UserId).not_null())
                    .col(
                        string(Post::CreatedAt)
                            .not_null()
                            .default("CURRENT_TIMESTAMP"),
                    )
                    .to_owned(),
            )
            .await
            .expect("create table posts");

        manager
            .create_foreign_key(
                ForeignKey::create()
                    .name("fk_user_id")
                    .from(Post::Table, Post::UserId)
                    .to(Users::Table, Users::Id)
                    .on_delete(ForeignKeyAction::Cascade)
                    .to_owned(),
            )
            .await
            .expect("create foreign key fk_user_id");

        manager
            .create_index(
                Index::create()
                    .name("idx_user_id")
                    .table(Post::Table)
                    .col(Post::UserId)
                    .to_owned(),
            )
            .await
    }

    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .drop_table(Table::drop().table(Post::Table).to_owned())
            .await
    }
}

#[derive(DeriveIden)]
enum Post {
    Table,
    Id,
    Body,
    UserId,
    CreatedAt,
}
```

## File: migration/src/main.rs
```rust
use sea_orm_migration::prelude::*;

#[async_std::main]
async fn main() {
    cli::run_cli(migration::Migrator).await;
}
```

## File: migration/Cargo.toml
```toml
[package]
name = "migration"
version = "0.1.0"
edition = "2021"
publish = false

[lib]
name = "migration"
path = "src/lib.rs"

[dependencies]
async-std = { version = "1", features = ["attributes", "tokio1"] }

[dependencies.sea-orm-migration]
version = "1.1.4"
features = ["sqlx-postgres", "runtime-tokio-rustls"]
```

## File: migration/README.md
```markdown
# Running Migrator CLI

- Generate a new migration file
    ```sh
    cargo run -- generate MIGRATION_NAME
    ```
- Apply all pending migrations
    ```sh
    cargo run
    ```
    ```sh
    cargo run -- up
    ```
- Apply first 10 pending migrations
    ```sh
    cargo run -- up -n 10
    ```
- Rollback last applied migrations
    ```sh
    cargo run -- down
    ```
- Rollback last 10 applied migrations
    ```sh
    cargo run -- down -n 10
    ```
- Drop all tables from the database, then reapply all migrations
    ```sh
    cargo run -- fresh
    ```
- Rollback all applied migrations, then reapply all migrations
    ```sh
    cargo run -- refresh
    ```
- Rollback all applied migrations
    ```sh
    cargo run -- reset
    ```
- Check the status of all migrations
    ```sh
    cargo run -- status
    ```
```

## File: proto/post.proto
```protobuf
syntax = "proto3";

package post;

import "google/protobuf/wrappers.proto";

service PostService {
  // 投稿作成
  rpc CreatePost (CreatePostRequest) returns (CreatePostResponse);
  // 投稿一覧取得
  rpc ListPosts (ListPostsRequest) returns (ListPostsResponse);
  // 投稿詳細取得
  rpc GetPost (GetPostRequest) returns (GetPostResponse);
  // 投稿削除
  rpc DeletePost (DeletePostRequest) returns (DeletePostResponse);
}

message CreatePostRequest {
  string body = 1;
  uint64 user_id = 2;
}

message CreatePostResponse {
  Post post = 1;
}

message ListPostsRequest {
  int32 page = 1;
  int32 per_page = 2;
}

message Post {
  uint64 id = 1;
  string body = 2;
  uint64 user_id = 3;
  string created_at = 4;
}

message ListPostsResponse {
  repeated Post posts = 1;
}

message GetPostRequest {
  uint64 id = 1;
}

message GetPostResponse {
  Post post = 1;
}

message DeletePostRequest {
  uint64 id = 1;
}

message DeletePostResponse {
  bool success = 1;
}
```

## File: proto/user.proto
```protobuf
syntax = "proto3";

package user;

import "google/protobuf/wrappers.proto";

service UserService {
  // ユーザ作成、一覧、詳細、更新、削除の RPC を定義
  rpc CreateUser (CreateUserRequest) returns (CreateUserResponse);
  rpc ListUsers (ListUsersRequest) returns (ListUsersResponse);
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
  rpc UpdateUser (UpdateUserRequest) returns (UpdateUserResponse);
  rpc DeleteUser (DeleteUserRequest) returns (DeleteUserResponse);
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
  google.protobuf.StringValue gender = 3;
  google.protobuf.StringValue address = 4;
  google.protobuf.StringValue description = 5;
  uint32 age = 6;
}

message CreateUserResponse {
  User user = 1;
}

// ユーザ一覧取得（検索）のリクエストに、検索条件を追加
message ListUsersRequest {
  int32 page = 1;
  int32 per_page = 2;
  // 検索条件として、以下のフィールドが指定された場合、その値でフィルタします
  google.protobuf.StringValue gender = 3;    // 性別での検索
  google.protobuf.StringValue address = 4;   // 住みでの検索
  google.protobuf.StringValue name = 5;  // 名前での検索
}

message User {
  uint64 id = 1;
  google.protobuf.StringValue name = 2;
  google.protobuf.StringValue email = 3;
  google.protobuf.StringValue gender = 4;
  google.protobuf.StringValue address = 5;
  google.protobuf.StringValue description = 6;
  uint32 age = 7;
}

message ListUsersResponse {
  repeated User users = 1;
}

message GetUserRequest {
  uint64 id = 1;
}

message GetUserResponse {
  User user = 1;
}

message UpdateUserRequest {
  uint64 id = 1;
  google.protobuf.StringValue name = 2;
  google.protobuf.StringValue email = 3;
  google.protobuf.StringValue gender = 4;
  google.protobuf.StringValue address = 5;
  google.protobuf.StringValue description = 6;
  google.protobuf.UInt32Value age = 7;
}

message UpdateUserResponse {
  User user = 1;
}

message DeleteUserRequest {
  uint64 id = 1;
}

message DeleteUserResponse {
  bool success = 1;
}
```

## File: src/domain/entity/mod.rs
```rust
//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0

pub mod prelude;

pub mod post;
pub mod users;
```

## File: src/domain/entity/post.rs
```rust
//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0

use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "post")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub body: String,
    pub user_id: i32,
    pub created_at: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::users::Entity",
        from = "Column::UserId",
        to = "super::users::Column::Id",
        on_update = "NoAction",
        on_delete = "Cascade"
    )]
    Users,
}

impl Related<super::users::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Users.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

## File: src/domain/entity/prelude.rs
```rust
//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0

pub use super::post::Entity as Post;
pub use super::users::Entity as Users;
```

## File: src/domain/entity/users.rs
```rust
//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.0

use sea_orm::ActiveValue::Set;
use sea_orm::entity::prelude::*;
use sea_orm::NotSet;
use crate::domain::entity::users;
use crate::user_proto::User;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub email: String,
    pub description: Option<String>,
    pub age: Option<i32>,
    pub gender: Option<String>,
    pub address: Option<String>,
    pub created_at: DateTime,
    pub updated_at: DateTime,
    pub deleted_at: Option<DateTime>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::post::Entity")]
    Post,
}

impl Related<super::post::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Post.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

## File: src/domain/repository/mod.rs
```rust
pub mod post;
pub mod user;
```

## File: src/domain/repository/post.rs
```rust
use crate::domain::entity::post::Model as Post;
use async_trait::async_trait;
use sea_orm::DbErr;

#[async_trait]
pub trait PostRepository {
    async fn find_all(&self) -> Result<Vec<Post>, DbErr>;
    async fn get_by_id(&self, id: i32) -> Result<Option<Post>, DbErr>;
    async fn find_by_user_id(&self, user_id: i32) -> Result<Vec<Post>, DbErr>;
    async fn insert(&self, body: String, user_id: i32) -> Result<Post, DbErr>;
    async fn update(&self, id: i32, body: String) -> Result<Post, DbErr>;
    async fn delete(&self, id: i32) -> Result<(), DbErr>;
}
```

## File: src/domain/repository/user.rs
```rust
use crate::domain::entity::users::Model as User;
use async_trait::async_trait;

#[async_trait]
pub trait UserRepository {
    async fn get_by_id(&self, id: i32) -> Result<User, sqlx::Error>;
    async fn list(&self) -> Result<Vec<User>, sqlx::Error>;
    async fn create(
        &self,
        name: String,
        email: String,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error>;
    async fn update(
        &self,
        id: i32,
        name: Option<String>,
        email: Option<String>,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error>;
    async fn delete(&self, id: i32) -> Result<User, sqlx::Error>;
    async fn hard_delete(&self, id: i32) -> Result<(), sqlx::Error>;
}
```

## File: src/domain/mod.rs
```rust
pub mod entity;
pub mod repository;
```

## File: src/handler/mod.rs
```rust
pub mod user_handler;
pub mod post_handler;
```

## File: src/handler/post_handler.rs
```rust
use crate::post_proto::post_service_server::PostService;
use crate::post_proto::{
    CreatePostRequest, CreatePostResponse, DeletePostRequest, DeletePostResponse, GetPostRequest,
    GetPostResponse, ListPostsRequest, ListPostsResponse, Post,
};
use crate::usecase::post_usecase::PostUseCase;
use sea_orm::DbErr;
use tonic::{Request, Response, Status};

pub struct PostHandler<U> {
    usecase: U,
}

impl<U: PostUseCase> PostHandler<U> {
    pub fn new(usecase: U) -> Self {
        Self { usecase }
    }
}

#[tonic::async_trait]
impl<U: PostUseCase + Send + Sync + 'static> PostService for PostHandler<U> {
    async fn create_post(
        &self,
        request: Request<CreatePostRequest>,
    ) -> Result<Response<CreatePostResponse>, Status> {
        let req = request.into_inner();
        let post = self
            .usecase
            .create_post(req.body, req.user_id as i32)
            .await
            .map_err(|e| Status::internal(e.to_string()))?;

        Ok(Response::new(CreatePostResponse {
            post: Some(Post {
                id: post.id as u64,
                body: post.body,
                user_id: post.user_id as u64,
                created_at: post.created_at,
            }),
        }))
    }

    async fn list_posts(
        &self,
        request: Request<ListPostsRequest>,
    ) -> Result<Response<ListPostsResponse>, Status> {
        let _req = request.into_inner();
        let posts = self
            .usecase
            .list_posts()
            .await
            .map_err(|e| Status::internal(e.to_string()))?;

        let posts = posts
            .into_iter()
            .map(|p| Post {
                id: p.id as u64,
                body: p.body,
                user_id: p.user_id as u64,
                created_at: p.created_at,
            })
            .collect();

        Ok(Response::new(ListPostsResponse { posts }))
    }

    async fn get_post(
        &self,
        request: Request<GetPostRequest>,
    ) -> Result<Response<GetPostResponse>, Status> {
        let req = request.into_inner();
        let post = self
            .usecase
            .get_post(req.id as i32)
            .await
            .map_err(|e| match e {
                DbErr::RecordNotFound(_) => Status::not_found("Post not found"),
                _ => Status::internal(e.to_string()),
            })?
            .ok_or_else(|| Status::not_found("Post not found"))?;

        Ok(Response::new(GetPostResponse {
            post: Some(Post {
                id: post.id as u64,
                body: post.body,
                user_id: post.user_id as u64,
                created_at: post.created_at,
            }),
        }))
    }

    async fn delete_post(
        &self,
        request: Request<DeletePostRequest>,
    ) -> Result<Response<DeletePostResponse>, Status> {
        let req = request.into_inner();

        self.usecase
            .delete_post(req.id as i32)
            .await
            .map_err(|e| match e {
                DbErr::RecordNotFound(_) => Status::not_found("Post not found"),
                _ => Status::internal(e.to_string()),
            })?;

        Ok(Response::new(DeletePostResponse { success: true }))
    }
}
```

## File: src/handler/user_handler.rs
```rust
use crate::usecase::user_usecase::UserUseCase;
use crate::user_proto::user_service_server::UserService;
use crate::user_proto::{
    CreateUserRequest, CreateUserResponse, DeleteUserRequest, DeleteUserResponse, GetUserRequest,
    GetUserResponse, ListUsersRequest, ListUsersResponse, UpdateUserRequest, UpdateUserResponse,
    User,
};
use tonic::{Request, Response, Status};

pub struct UserHandler<U> {
    usecase: U,
}

impl<U: UserUseCase> UserHandler<U> {
    pub fn new(usecase: U) -> Self {
        Self { usecase }
    }
}

#[tonic::async_trait]
impl<U: UserUseCase + Send + Sync + 'static> UserService for UserHandler<U> {
    async fn create_user(
        &self,
        request: Request<CreateUserRequest>,
    ) -> Result<Response<CreateUserResponse>, Status> {
        let req = request.into_inner();
        let user = self
            .usecase
            .create_user(
                req.name,
                req.email,
                req.description,
                Some(req.age as i32),
                req.gender,
                req.address,
            )
            .await
            .map_err(|e| Status::internal(e.to_string()))?;

        Ok(Response::new(CreateUserResponse {
            user: Some(User {
                id: user.id as u64,
                name: Some(user.name),
                email: Some(user.email),
                age: user.age.unwrap_or(0) as u32,
                address: user.address,
                description: user.description,
                gender: user.gender,
            }),
        }))
    }

    async fn list_users(
        &self,
        request: Request<ListUsersRequest>,
    ) -> Result<Response<ListUsersResponse>, Status> {
        let _req = request.into_inner();
        let users = self
            .usecase
            .list_users()
            .await
            .map_err(|e| Status::internal(e.to_string()))?;

        let users = users
            .into_iter()
            .map(|u| User {
                id: u.id as u64,
                name: Some(u.name),
                email: Some(u.email),
                gender: u.gender,
                address: u.address,
                age: u.age.unwrap_or(0) as u32,
                description: u.description,
            })
            .collect();

        Ok(Response::new(ListUsersResponse { users }))
    }

    async fn get_user(
        &self,
        request: Request<GetUserRequest>,
    ) -> Result<Response<GetUserResponse>, Status> {
        let req = request.into_inner();
        let user = self
            .usecase
            .get_user(req.id as i32)
            .await
            .map_err(|e| match e {
                sqlx::Error::RowNotFound => Status::not_found("User not found"),
                _ => Status::internal(e.to_string()),
            })?;

        Ok(Response::new(GetUserResponse {
            user: Some(User {
                id: user.id as u64,
                name: Some(user.name),
                email: Some(user.email),
                gender: user.gender,
                address: user.address,
                age: user.age.unwrap_or(0) as u32,
                description: user.description,
            }),
        }))
    }

    async fn update_user(
        &self,
        request: Request<UpdateUserRequest>,
    ) -> Result<Response<UpdateUserResponse>, Status> {
        let req = request.into_inner();

        // UpdateUserRequest の各フィールドを usecase の update_user に渡す
        let user = self
            .usecase
            .update_user(
                req.id as i32,
                req.name,
                req.email,
                req.description,
                req.age.map(|a| a as i32),
                req.gender,
                req.address,
            )
            .await
            .map_err(|e| match e {
                sqlx::Error::RowNotFound => Status::not_found("User not found"),
                _ => Status::internal(e.to_string()),
            })?;

        Ok(Response::new(UpdateUserResponse {
            user: Some(User {
                id: user.id as u64,
                name: Some(user.name),
                email: Some(user.email),
                gender: user.gender,
                address: user.address,
                age: user.age.unwrap_or(0) as u32,
                description: user.description,
            }),
        }))
    }

    async fn delete_user(
        &self,
        request: Request<DeleteUserRequest>,
    ) -> Result<Response<DeleteUserResponse>, Status> {
        let req = request.into_inner();

        self.usecase
            .delete_user(req.id as i32)
            .await
            .map_err(|e| match e {
                sqlx::Error::RowNotFound => Status::not_found("User not found"),
                _ => Status::internal(e.to_string()),
            })?;

        Ok(Response::new(DeleteUserResponse { success: true }))
    }
}
```

## File: src/infra/client.rs
```rust
use sqlx::{PgPool, postgres::PgPoolOptions};

pub async fn create_pg_pool() -> Result<PgPool, sqlx::Error> {
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");
    PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await
}
```

## File: src/infra/mod.rs
```rust
pub mod client;
```

## File: src/repository/mod.rs
```rust
pub mod post_repository;
pub mod user_repository;
```

## File: src/repository/post_repository.rs
```rust
use crate::domain::entity::post;
use crate::domain::entity::post::{Column, Entity as Posts, Model as Post};
use crate::domain::repository::post::PostRepository;
use async_trait::async_trait;
use sea_orm::entity::prelude::*;
use sea_orm::{ColumnTrait, DatabaseConnection, NotSet, Set};

pub struct PgPostRepository {
    db: DatabaseConnection,
}

impl PgPostRepository {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
}

#[async_trait]
impl PostRepository for PgPostRepository {
    async fn find_all(&self) -> Result<Vec<Post>, DbErr> {
        Posts::find()
            .all(&self.db)
            .await
            .map_err(|e| DbErr::Exec(RuntimeErr::Internal(format!("Error: {}", e.to_string()))))
    }

    async fn get_by_id(&self, id: i32) -> Result<Option<Post>, DbErr> {
        Posts::find_by_id(id)
            .one(&self.db)
            .await
            .map_err(|_e| DbErr::RecordNotFound(format!("Post with id {} not found", id)))
    }

    async fn find_by_user_id(&self, user_id: i32) -> Result<Vec<Post>, DbErr> {
        Posts::find()
            .filter(Column::UserId.eq(user_id))
            .all(&self.db)
            .await
            .map_err(|e| DbErr::Exec(RuntimeErr::Internal(format!("Error: {}", e.to_string()))))
    }

    async fn insert(&self, body: String, user_id: i32) -> Result<Post, DbErr> {
        let _now = chrono::Utc::now().naive_utc();
        let post_data = post::ActiveModel {
            id: NotSet,
            body: Set(body.clone()),
            user_id: Set(user_id),
            ..Default::default()
        };

        post_data
            .insert(&self.db)
            .await
            .map_err(|e| DbErr::Exec(RuntimeErr::Internal(format!("Error: {}", e.to_string()))))
    }

    async fn update(&self, id: i32, body: String) -> Result<Post, DbErr> {
        let existing_post = Posts::find_by_id(id)
            .one(&self.db)
            .await
            .map_err(|e| DbErr::Custom(format!("Error retrieving post: {}", e)))?
            .ok_or(DbErr::RecordNotFound(format!(
                "Post with id {} not found",
                id
            )))?;

        let mut active_post: post::ActiveModel = existing_post.into();
        active_post.body = Set(body.clone());

        active_post
            .update(&self.db)
            .await
            .map_err(|e| DbErr::Exec(RuntimeErr::Internal(format!("Error updating post: {}", e))))
    }

    async fn delete(&self, id: i32) -> Result<(), DbErr> {
        Posts::delete_by_id(id)
            .exec(&self.db)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))
            .expect("delete post");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::entity::post::Model as Post;
    use crate::domain::repository::post::PostRepository;
    use dotenv::dotenv;
    use sea_orm::{Database, DatabaseConnection, NotSet, Set};
    use std::env;
    use tokio;

    // テスト用データベース接続をセットアップする関数
    async fn setup_test_db() -> DatabaseConnection {
        dotenv().ok();
        let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        Database::connect(&database_url)
            .await
            .expect("Failed to connect to database")
    }

    // 修正: ダミーユーザを実際に users テーブルへ挿入する
    async fn insert_dummy_user(db: &DatabaseConnection) -> i32 {
        use crate::domain::entity::users::{
            ActiveModel as UserActiveModel, Entity as Users, Model as UserModel,
        };
        let dummy_user = UserActiveModel {
            id: NotSet,
            name: Set("dummy user".to_string()),
            email: Set("dummy@example.com".to_string()),
            description: NotSet,
            age: NotSet,
            gender: NotSet,
            address: NotSet,
            created_at: Set(chrono::Utc::now().naive_utc()),
            updated_at: Set(chrono::Utc::now().naive_utc()),
            deleted_at: NotSet,
        };
        let inserted: UserModel = dummy_user
            .insert(db)
            .await
            .expect("Insert dummy user failed");
        inserted.id
    }

    #[tokio::test]
    async fn test_insert_and_get_by_id() {
        let db = setup_test_db().await;
        // 実際に dummy user を挿入して有効な user_id を取得
        let dummy_user_id = insert_dummy_user(&db).await;
        let repo = PgPostRepository::new(db);

        // insert を body と user_id で呼び出す
        let inserted_post = repo
            .insert("Test post body".to_string(), dummy_user_id)
            .await
            .expect("Insert failed");
        assert!(inserted_post.id > 0);

        // get_by_id で取得
        let retrieved = repo
            .get_by_id(inserted_post.id)
            .await
            .expect("Get by id failed");
        assert!(retrieved.is_some());
        let retrieved_post = retrieved.unwrap();
        assert_eq!(retrieved_post.body, inserted_post.body);
        assert_eq!(retrieved_post.user_id, inserted_post.user_id);
    }

    #[tokio::test]
    async fn test_update_post() {
        let db = setup_test_db().await;
        let dummy_user_id = insert_dummy_user(&db).await;
        let repo = PgPostRepository::new(db);

        // 新規レコードを挿入
        let inserted_post = repo
            .insert("Original body".to_string(), dummy_user_id)
            .await
            .expect("Insert failed");

        // update: id と新しい body を渡す
        let updated_post = repo
            .update(inserted_post.id, "Updated body".to_string())
            .await
            .expect("Update failed");
        assert_eq!(updated_post.body, "Updated body");
    }

    #[tokio::test]
    async fn test_delete_post() {
        let db = setup_test_db().await;
        let dummy_user_id = insert_dummy_user(&db).await;
        let repo = PgPostRepository::new(db);

        // 削除対象のレコードを挿入
        let inserted_post = repo
            .insert("Post to be deleted".to_string(), dummy_user_id)
            .await
            .expect("Insert failed");

        // delete を呼び出し
        repo.delete(inserted_post.id).await.expect("Delete failed");

        // 削除後、get_by_id で取得し、None となることを確認
        let result = repo.get_by_id(inserted_post.id).await;
        match result {
            Ok(opt) => assert!(opt.is_none(), "Deleted post still exists"),
            Err(e) => eprintln!("Error on get_by_id: {:?}", e),
        }
    }

    #[tokio::test]
    async fn test_find_by_user_id() {
        let db = setup_test_db().await;
        let dummy_user_id = insert_dummy_user(&db).await;
        let repo = PgPostRepository::new(db);

        // 同一 user_id のレコードを2件挿入
        let _ = repo
            .insert("User post 1".to_string(), dummy_user_id)
            .await
            .expect("Insert post1 failed");
        let _ = repo
            .insert("User post 2".to_string(), dummy_user_id)
            .await
            .expect("Insert post2 failed");

        let posts = repo
            .find_by_user_id(dummy_user_id)
            .await
            .expect("Find by user_id failed");
        // dummy_user_id の投稿が 2 件以上あることを確認
        assert!(posts.len() >= 2);
        for post in posts {
            assert_eq!(post.user_id, dummy_user_id);
        }
    }
}
```

## File: src/repository/user_repository.rs
```rust
// repository.rs
use crate::domain::entity::users::Model as User;
use crate::domain::entity::users::{self, Entity as Users};
use async_trait::async_trait;
use sea_orm::{ActiveModelTrait, ActiveValue::NotSet, DatabaseConnection, EntityTrait, Set};
use crate::domain::repository::user::UserRepository;

/// PgUserRepository の実装
pub struct PgUserRepository {
    pool: DatabaseConnection,
}

impl PgUserRepository {
    pub fn new(pool: DatabaseConnection) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for PgUserRepository {
    async fn get_by_id(&self, id: i32) -> Result<User, sqlx::Error> {
        Users::find_by_id(id)
            .one(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))?
            .ok_or(sqlx::Error::RowNotFound)
    }

    async fn list(&self) -> Result<Vec<User>, sqlx::Error> {
        Users::find()
            .all(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))
    }

    async fn create(
        &self,
        name: String,
        email: String,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error> {
        let now = chrono::Utc::now().naive_utc();
        let user = users::ActiveModel {
            id: NotSet,
            name: Set(name),
            email: Set(email),
            description: Set(description),
            age: Set(age),
            gender: Set(gender),
            address: Set(address),
            created_at: Default::default(),
            updated_at: Default::default(),
            deleted_at: Default::default(),
        };

        user.insert(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))
    }

    async fn update(
        &self,
        id: i32,
        name: Option<String>,
        email: Option<String>,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error> {
        let user = Users::find_by_id(id)
            .one(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))?
            .ok_or(sqlx::Error::RowNotFound)?;

        let mut user: users::ActiveModel = user.into();

        if let Some(name) = name {
            user.name = Set(name);
        }
        if let Some(email) = email {
            user.email = Set(email);
        }
        if let Some(desc) = description {
            user.description = Set(Some(desc));
        }
        if let Some(age) = age {
            user.age = Set(Some(age));
        }
        if let Some(gender) = gender {
            user.gender = Set(Some(gender));
        }
        if let Some(addr) = address {
            user.address = Set(Some(addr));
        }
        user.updated_at = Set(chrono::Utc::now().naive_utc());

        user.update(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))
    }

    async fn delete(&self, id: i32) -> Result<User, sqlx::Error> {
        let user = self.get_by_id(id).await?;
        let mut user: users::ActiveModel = user.into();

        user.deleted_at = Set(Some(chrono::Utc::now().naive_utc()));
        user.update(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))
    }

    async fn hard_delete(&self, id: i32) -> Result<(), sqlx::Error> {
        Users::delete_by_id(id)
            .exec(&self.pool)
            .await
            .map_err(|e| sqlx::Error::Protocol(e.to_string().into()))?;
        Ok(())
    }
}

/// モック実装（テスト用）
#[cfg(test)]
pub mod mock {
    use super::*;
    use std::collections::HashMap;
    use std::sync::Mutex;

    pub struct MockUserRepository {
        pub users: Mutex<HashMap<i32, User>>,
        pub next_id: Mutex<i32>,
    }

    impl MockUserRepository {
        pub fn new() -> Self {
            Self {
                users: Mutex::new(HashMap::new()),
                next_id: Mutex::new(1),
            }
        }
    }

    #[async_trait]
    impl UserRepository for MockUserRepository {
        async fn get_by_id(&self, id: i32) -> Result<User, sqlx::Error> {
            let users = self.users.lock().unwrap();
            users
                .get(&id)
                .cloned()
                .ok_or_else(|| sqlx::Error::RowNotFound)
        }

        async fn list(&self) -> Result<Vec<User>, sqlx::Error> {
            let users = self.users.lock().unwrap();
            Ok(users.values().cloned().collect())
        }

        async fn create(
            &self,
            name: String,
            email: String,
            description: Option<String>,
            age: Option<i32>,
            gender: Option<String>,
            address: Option<String>,
        ) -> Result<User, sqlx::Error> {
            let mut next_id = self.next_id.lock().unwrap();
            let id = *next_id;
            *next_id += 1;

            let now = chrono::Utc::now().naive_utc();
            let user = User {
                id,
                name,
                email,
                description,
                age,
                gender,
                address,
                created_at: now,
                updated_at: now,
                deleted_at: None,
            };

            let mut users = self.users.lock().unwrap();
            users.insert(id, user.clone());
            Ok(user)
        }

        async fn update(
            &self,
            id: i32,
            name: Option<String>,
            email: Option<String>,
            description: Option<String>,
            age: Option<i32>,
            gender: Option<String>,
            address: Option<String>,
        ) -> Result<User, sqlx::Error> {
            let mut users = self.users.lock().unwrap();
            if let Some(user) = users.get_mut(&id) {
                if let Some(name) = name {
                    user.name = name;
                }
                if let Some(email) = email {
                    user.email = email;
                }
                if let Some(desc) = description {
                    user.description = Some(desc);
                }
                if let Some(age) = age {
                    user.age = Some(age);
                }
                if let Some(gender) = gender {
                    user.gender = Some(gender);
                }
                if let Some(addr) = address {
                    user.address = Some(addr);
                }
                user.updated_at = chrono::Utc::now().naive_utc();
                Ok(user.clone())
            } else {
                Err(sqlx::Error::RowNotFound)
            }
        }

        async fn delete(&self, id: i32) -> Result<User, sqlx::Error> {
            let mut users = self.users.lock().unwrap();
            if let Some(user) = users.get_mut(&id) {
                user.deleted_at = Some(chrono::Utc::now().naive_utc());
                Ok(user.clone())
            } else {
                Err(sqlx::Error::RowNotFound)
            }
        }

        async fn hard_delete(&self, id: i32) -> Result<(), sqlx::Error> {
            let mut users = self.users.lock().unwrap();
            if users.remove(&id).is_some() {
                Ok(())
            } else {
                Err(sqlx::Error::RowNotFound)
            }
        }
    }
}

/// テストコード
#[cfg(test)]
mod tests {
    use super::*;
    use dotenv::dotenv;
    use sea_orm::Database;
    use std::env;

    async fn setup_test_db() -> DatabaseConnection {
        dotenv().ok();
        let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        Database::connect(&database_url)
            .await
            .expect("Failed to connect to database")
    }

    mod pg_repository_tests {
        use super::*;

        async fn create_test_user(repo: &PgUserRepository) -> User {
            repo.create(
                "Test User".to_string(),
                "test@example.com".to_string(),
                Some("Test Description".to_string()),
                Some(25),
                Some("Male".to_string()),
                None, // address
            )
            .await
            .expect("Failed to create test user")
        }

        #[tokio::test]
        async fn test_create_user() {
            let pool = setup_test_db().await;
            let repo = PgUserRepository::new(pool);

            let user = repo
                .create(
                    "Test User".to_string(),
                    "test@example.com".to_string(),
                    Some("Test Description".to_string()),
                    Some(25),
                    Some("Male".to_string()),
                    None,
                )
                .await
                .expect("Failed to create user");

            assert_eq!(user.name, "Test User");
            assert_eq!(user.description, Some("Test Description".to_string()));
            assert_eq!(user.age, Some(25));
            assert_eq!(user.gender, Some("Male".to_string()));
            assert!(user.deleted_at.is_none());

            repo.hard_delete(user.id).await.expect("Failed to cleanup");
        }

        #[tokio::test]
        async fn test_get_user_by_id() {
            let pool = setup_test_db().await;
            let repo = PgUserRepository::new(pool);

            let created_user = create_test_user(&repo).await;

            let retrieved_user = repo
                .get_by_id(created_user.id)
                .await
                .expect("Failed to get user");

            assert_eq!(retrieved_user.id, created_user.id);
            assert_eq!(retrieved_user.name, created_user.name);
            assert_eq!(retrieved_user.description, created_user.description);
            assert_eq!(retrieved_user.age, created_user.age);
            assert_eq!(retrieved_user.gender, created_user.gender);

            repo.hard_delete(created_user.id)
                .await
                .expect("Failed to cleanup");
        }

        #[tokio::test]
        async fn test_list_users() {
            let pool = setup_test_db().await;
            let repo = PgUserRepository::new(pool);

            let user1 = create_test_user(&repo).await;
            let user2 = repo
                .create(
                    "Another User".to_string(),
                    "another@example.com".to_string(),
                    Some("Another Description".to_string()),
                    Some(30),
                    Some("Female".to_string()),
                    None,
                )
                .await
                .expect("Failed to create second user");

            let users = repo.list().await.expect("Failed to list users");

            assert!(users.len() >= 2);
            assert!(users.iter().any(|u| u.id == user1.id));
            assert!(users.iter().any(|u| u.id == user2.id));

            repo.hard_delete(user1.id).await.expect("Failed to cleanup");
            repo.hard_delete(user2.id).await.expect("Failed to cleanup");
        }

        #[tokio::test]
        async fn test_update_user() {
            let pool = setup_test_db().await;
            let repo = PgUserRepository::new(pool);

            let created_user = create_test_user(&repo).await;

            let updated_user = repo
                .update(
                    created_user.id,
                    Some("Updated Name".to_string()),
                    Some("updated@example.com".to_string()),
                    Some("Updated Description".to_string()),
                    Some(26),
                    Some("Female".to_string()),
                    None, // address
                )
                .await
                .expect("Failed to update user");

            assert_eq!(updated_user.id, created_user.id);
            assert_eq!(updated_user.name, "Updated Name");
            assert_eq!(
                updated_user.description,
                Some("Updated Description".to_string())
            );
            assert_eq!(updated_user.age, Some(26));
            assert_eq!(updated_user.gender, Some("Female".to_string()));
            assert!(updated_user.updated_at > created_user.updated_at);

            repo.hard_delete(created_user.id)
                .await
                .expect("Failed to cleanup");
        }

        #[tokio::test]
        async fn test_partial_update() {
            let pool = setup_test_db().await;
            let repo = PgUserRepository::new(pool);

            let created_user = create_test_user(&repo).await;

            let updated_user = repo
                .update(
                    created_user.id,
                    Some("Updated Name".to_string()),
                    None, // email は更新しない
                    None, // description は更新しない
                    None, // age は更新しない
                    None, // gender は更新しない
                    None, // address は更新しない
                )
                .await
                .expect("Failed to partially update user");

            assert_eq!(updated_user.name, "Updated Name");
            assert_eq!(updated_user.description, created_user.description);
            assert_eq!(updated_user.age, created_user.age);
            assert_eq!(updated_user.gender, created_user.gender);

            repo.hard_delete(created_user.id)
                .await
                .expect("Failed to cleanup");
        }

        #[tokio::test]
        async fn test_delete_user() {
            let pool = setup_test_db().await;
            let repo = PgUserRepository::new(pool);

            let created_user = create_test_user(&repo).await;

            let deleted_user = repo
                .delete(created_user.id)
                .await
                .expect("Failed to delete user");

            assert_eq!(deleted_user.id, created_user.id);
            assert!(deleted_user.deleted_at.is_some());

            repo.hard_delete(created_user.id)
                .await
                .expect("Failed to hard delete user");

            let result = repo.get_by_id(created_user.id).await;
            assert!(result.is_err());
        }
    }

    mod mock_repository_tests {
        use super::*;

        #[tokio::test]
        async fn test_mock_create_and_get() {
            let repo = mock::MockUserRepository::new();

            let user = repo
                .create(
                    "Test User".to_string(),
                    "test@example.com".to_string(),
                    Some("Test Description".to_string()),
                    Some(25),
                    Some("Male".to_string()),
                    None,
                )
                .await
                .expect("Failed to create user");

            assert_eq!(user.name, "Test User");

            let retrieved = repo.get_by_id(user.id).await.expect("Failed to get user");
            assert_eq!(retrieved.id, user.id);
            assert_eq!(retrieved.name, "Test User");
        }

        #[tokio::test]
        async fn test_mock_list_users() {
            let repo = mock::MockUserRepository::new();

            let user1 = repo
                .create(
                    "User 1".to_string(),
                    "user1@example.com".to_string(),
                    None,
                    None,
                    None,
                    None,
                )
                .await
                .expect("Failed to create user 1");
            let user2 = repo
                .create(
                    "User 2".to_string(),
                    "user2@example.com".to_string(),
                    None,
                    None,
                    None,
                    None,
                )
                .await
                .expect("Failed to create user 2");

            let users = repo.list().await.expect("Failed to list users");
            assert_eq!(users.len(), 2);
            assert!(users.iter().any(|u| u.id == user1.id));
            assert!(users.iter().any(|u| u.id == user2.id));
        }

        #[tokio::test]
        async fn test_mock_update() {
            let repo = mock::MockUserRepository::new();

            let user = repo
                .create(
                    "Initial Name".to_string(),
                    "initial@example.com".to_string(),
                    None,
                    None,
                    None,
                    None,
                )
                .await
                .expect("Failed to create user");

            let updated = repo
                .update(
                    user.id,
                    Some("Updated Name".to_string()),
                    None, // email は更新しない
                    None, // description は更新しない
                    None, // age は更新しない
                    None, // gender は更新しない
                    None, // address は更新しない
                )
                .await
                .expect("Failed to update user");

            assert_eq!(updated.name, "Updated Name");
        }

        #[tokio::test]
        async fn test_mock_delete() {
            let repo = mock::MockUserRepository::new();

            let user = repo
                .create(
                    "Test User".to_string(),
                    "test@example.com".to_string(),
                    None,
                    None,
                    None,
                    None,
                )
                .await
                .expect("Failed to create user");

            let deleted = repo.delete(user.id).await.expect("Failed to delete user");
            assert!(deleted.deleted_at.is_some());

            repo.hard_delete(user.id)
                .await
                .expect("Failed to hard delete");
            let result = repo.get_by_id(user.id).await;
            assert!(matches!(result, Err(sqlx::Error::RowNotFound)));
        }

        #[tokio::test]
        async fn test_mock_not_found() {
            let repo = mock::MockUserRepository::new();
            let result = repo.get_by_id(999).await;
            assert!(matches!(result, Err(sqlx::Error::RowNotFound)));
        }
    }
}
```

## File: src/usecase/mod.rs
```rust
pub mod post_usecase;
pub mod user_usecase;
```

## File: src/usecase/post_usecase.rs
```rust
use crate::domain::entity::post::Model as Post;
use crate::domain::repository::post::PostRepository;
use async_trait::async_trait;
use sea_orm::DbErr;

#[async_trait]
pub trait PostUseCase {
    async fn create_post(&self, body: String, user_id: i32) -> Result<Post, DbErr>;
    async fn get_post(&self, id: i32) -> Result<Option<Post>, DbErr>;
    async fn list_posts(&self) -> Result<Vec<Post>, DbErr>;
    async fn delete_post(&self, id: i32) -> Result<(), DbErr>;
}

pub struct PostUseCaseImpl<R> {
    repository: R,
}

impl<R: PostRepository> PostUseCaseImpl<R> {
    pub fn new(repository: R) -> Self {
        Self { repository }
    }
}

#[async_trait]
impl<R: PostRepository + Send + Sync> PostUseCase for PostUseCaseImpl<R> {
    async fn create_post(&self, body: String, user_id: i32) -> Result<Post, DbErr> {
        self.repository.insert(body, user_id).await
    }

    async fn get_post(&self, id: i32) -> Result<Option<Post>, DbErr> {
        self.repository.get_by_id(id).await
    }

    async fn list_posts(&self) -> Result<Vec<Post>, DbErr> {
        self.repository.find_all().await
    }

    async fn delete_post(&self, id: i32) -> Result<(), DbErr> {
        self.repository.delete(id).await
    }
}
```

## File: src/usecase/user_usecase.rs
```rust
use crate::domain::entity::users::Model as User;
use crate::domain::repository::user::UserRepository;
use async_trait::async_trait;

#[async_trait]
pub trait UserUseCase {
    async fn create_user(
        &self,
        name: String,
        email: String,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error>;

    async fn get_user(&self, id: i32) -> Result<User, sqlx::Error>;

    async fn list_users(&self) -> Result<Vec<User>, sqlx::Error>;

    // 修正: sex ではなく gender とし、email, address も含む全パラメータを渡す
    async fn update_user(
        &self,
        id: i32,
        name: Option<String>,
        email: Option<String>,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error>;

    async fn delete_user(&self, id: i32) -> Result<User, sqlx::Error>;
}

pub struct UserUseCaseImpl<R> {
    repository: R,
}

impl<R: UserRepository> UserUseCaseImpl<R> {
    pub fn new(repository: R) -> Self {
        Self { repository }
    }
}

#[async_trait]
impl<R: UserRepository + Send + Sync> UserUseCase for UserUseCaseImpl<R> {
    async fn create_user(
        &self,
        name: String,
        email: String,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error> {
        self.repository
            .create(name, email, description, age, gender, address)
            .await
    }

    async fn get_user(&self, id: i32) -> Result<User, sqlx::Error> {
        self.repository.get_by_id(id).await
    }

    async fn list_users(&self) -> Result<Vec<User>, sqlx::Error> {
        self.repository.list().await
    }

    async fn update_user(
        &self,
        id: i32,
        name: Option<String>,
        email: Option<String>,
        description: Option<String>,
        age: Option<i32>,
        gender: Option<String>,
        address: Option<String>,
    ) -> Result<User, sqlx::Error> {
        self.repository
            .update(id, name, email, description, age, gender, address)
            .await
    }

    async fn delete_user(&self, id: i32) -> Result<User, sqlx::Error> {
        self.repository.delete(id).await
    }
}
```

## File: src/main.rs
```rust
mod domain;
mod handler;
mod infra;
mod repository;
mod usecase;

use crate::handler::post_handler::PostHandler;
use crate::handler::user_handler::UserHandler;
use crate::repository::post_repository::PgPostRepository;
use crate::repository::user_repository::PgUserRepository;
use crate::usecase::post_usecase::PostUseCaseImpl;
use crate::usecase::user_usecase::UserUseCaseImpl;
use dotenv::dotenv;
use tonic::transport::Server;

mod user_proto {
    tonic::include_proto!("user");
}

mod post_proto {
    tonic::include_proto!("post");
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv().ok();

    // DATABASE_URL 環境変数から接続先を取得
    let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");

    // SeaORM を使ってデータベース接続を確立
    let pool = sea_orm::Database::connect(&database_url).await?;

    // リポジトリ、ユースケース、ハンドラを順次初期化
    let user_repository = PgUserRepository::new(pool.clone());
    let user_usecase = UserUseCaseImpl::new(user_repository);
    let user_handler = UserHandler::new(user_usecase);

    let post_repository = PgPostRepository::new(pool.clone());
    let post_usecase = PostUseCaseImpl::new(post_repository);
    let post_handler = PostHandler::new(post_usecase);

    let addr = "[::1]:50051".parse()?;
    println!("Server listening on {}", addr);

    // Tonic サーバーにハンドラを登録して起動
    Server::builder()
        .add_service(user_proto::user_service_server::UserServiceServer::new(
            user_handler,
        ))
        .add_service(post_proto::post_service_server::PostServiceServer::new(
            post_handler,
        ))
        .serve(addr)
        .await?;

    Ok(())
}
```

## File: .gitignore
```
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
.idea/
```

## File: .octocov.yml
```yaml
# generated by octocov init
coverage:
  if: true
testExecutionTime:
  if: true
diff:
  datastores:
    - artifact://${GITHUB_REPOSITORY}
comment:
  if: is_pull_request
summary:
  if: true
report:
  if: is_default_branch
  datastores:
    - artifact://${GITHUB_REPOSITORY}
```

## File: build.rs
```rust
use std::{env, path::PathBuf};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    tonic_build::compile_protos("proto/user.proto")?;
    tonic_build::compile_protos("proto/post.proto")?;

    Ok(())
}
```

## File: Cargo.toml
```toml
[package]
name = "talkapp"
version = "0.1.0"
edition = "2021"

[dependencies]
dotenv = "0.15.0"
prost = "0.13.4"
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres", "chrono"] }
thiserror = "2.0.11"
tokio = { version = "1.28", features = ["macros", "rt-multi-thread"] }
tonic = { version = "0.12", features = ["transport"] }
serde = { version = "1.0", features = ["derive"] }
sea-orm = { version = "1.1.5", features = ["sqlx-postgres", "runtime-tokio-native-tls"] }
sea-orm-migration = "1.1.4"
tracing = "0.1.41"
async-std = { version = "1", features = ["attributes", "tokio1"] }
chrono = "0.4.39"
async-trait = "0.1.86"
prost-types = "0.13.5"

[build-dependencies]
tonic-build = "0.12.3"
```

## File: docker-compose.yml
```yaml
services:
  postgres:
    image: postgres:14
    container_name: postgres
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
      POSTGRES_DB: talk_app
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## File: Makefile
```
refresh:
	cd migration && cargo run -- refresh
gen-entity:
	sea-orm-cli generate entity -u postgres://myuser:mypassword@localhost/talk_app -o src/domain/entity
```

## File: README.md
```markdown
# talkapp

## マイレーションファイル作成方法

```bash
sea-orm-cli migrate generate create_table_{テーブル名}
```

## マイレーション実行方法

```bash
cd migration
cargo run -- up

cd migration
cargo run -- refresh
```

## マイレーションロールバック方法

```bash
cd migration
cargo run -- down
```

## entity作成方法

```bash
sea-orm-cli generate entity -u postgres://myuser:mypassword@localhost/talk_app -o src/domain/entity
```
```
